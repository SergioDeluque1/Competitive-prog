#include <iostream>#include <vector>#include <algorithm> // for sort and greater// Global variablesstd::vector<bool> used; // Tracks which sticks are usedint targetLength;       // Desired length of each groupint numGroups;          // Number of groups neededint n;                  // Number of sticks (not actually used globally)// Recursive backtracking function to try forming groupsbool dfs(const std::vector<int>& sticks, int currentGroup, int currentSum, intstartIndex) {    // All groups are formed successfully    if (currentGroup == numGroups) return true;    // Current group completed; move to next group    if (currentSum == targetLength)        return dfs(sticks, currentGroup + 1, 0, 0);    int prev = -1;    int size = sticks.size();    for (int i = startIndex; i < size; ++i) {        // Skip stick if already used, exceeds group sum, or is duplicate of        previously tried stick        if (used[i] || currentSum + sticks[i] > targetLength || sticks[i] ==            prev)            continue;        used[i] = true;        // Try including this stick in current group        if (dfs(sticks, currentGroup, currentSum + sticks[i], i + 1))            return true;        // Backtrack        used[i] = false;        prev = sticks[i];        // Optimization: if first stick fails or group completes but doesn't        lead to solution, stop early        if (currentSum == 0 || currentSum + sticks[i] == targetLength)            return false;    }    return false;}int main() {    std::vector<std::vector<int>> allStickLists; // Holds multiple test cases    int n;    // Input phase: read multiple test cases until 0 is entered    while (std::cin >> n && n != 0) {        std::vector<int> sticks(n);        for (int i = 0; i < n; ++i) {            std::cin >> sticks[i];        }        allStickLists.push_back(sticks);    }    // Process each test case    for (const auto& sticks : allStickLists) {        int totalSum = 0;        // Compute total length of all sticks        for (int x : sticks)            totalSum += x;        // Sort sticks in descending order to optimize DFS (try longer sticks        first)        std::vector<int> sortedSticks = sticks;        std::sort(sortedSticks.begin(), sortedSticks.end(),                  std::greater<int>());        int answer = totalSum; // Default answer is total length (i.e., one big        stick)        int size = sortedSticks.size();        // Try all possible lengths L starting from the longest stick to total        length        for (int L = sortedSticks[0]; L <= totalSum; ++L) {            // Only try lengths that divide the total length evenly            if (totalSum % L != 0) continue;            targetLength = L;            numGroups = totalSum / L;            used.assign(size, false); // Reset usage for this test case            // Use DFS to check if it's possible to form equal-length groups            if (dfs(sortedSticks, 0, 0, 0)) {                answer = L;                break; // Found the smallest valid length, stop searching            }        }        // Output the minimal possible length to reconstruct the original stick        std::cout << answer << "\n";    }    return 0;}